/*
 * Copyright (c) 2013 - 2015, Freescale Semiconductor, Inc.
 * Copyright 2016-2017 NXP
 * All rights reserved.
 * 
 * SPDX-License-Identifier: BSD-3-Clause
 */

#include "ili9341.h"

/* FreeRTOS kernel includes. */
#include "FreeRTOS.h"
#include "task.h"
#include "queue.h"
#include "timers.h"

/* Freescale includes. */
#include "fsl_device_registers.h"
#include "fsl_debug_console.h"
#include "fsl_lpspi.h"
#include "fsl_lpspi_freertos.h"
#include "board.h"

#include "pin_mux.h"
#include "fsl_intmux.h"
#include "clock_config.h"
/*******************************************************************************
* Definitions
******************************************************************************/
/*Master related*/
#define EXAMPLE_LPSPI_MASTER_BASEADDR (LPSPI0)
#define EXAMPLE_LPSPI_MASTER_IRQN (LPSPI0_IRQn)
#define EXAMPLE_LPSPI_MASTER_CLOCK_NAME (kCLOCK_Lpspi0)
#define EXAMPLE_LPSPI_MASTER_CLOCK_SOURCE (kCLOCK_IpSrcFircAsync)
#define EXAMPLE_LPSPI_MASTER_CLOCK_FREQ (CLOCK_GetIpFreq(EXAMPLE_LPSPI_MASTER_CLOCK_NAME))
#define EXAMPLE_LPSPI_MASTER_PCS_FOR_INIT (kLPSPI_Pcs2)
#define EXAMPLE_LPSPI_MASTER_PCS_FOR_TRANSFER (kLPSPI_MasterPcs2)

/*Slave related*/
#define EXAMPLE_LPSPI_SLAVE_BASEADDR (LPSPI3)
#define EXAMPLE_LPSPI_SLAVE_IRQN (LPSPI3_IRQn)
#define EXAMPLE_LPSPI_SLAVE_CLOCK_NAME (kCLOCK_Lpspi3)
#define EXAMPLE_LPSPI_SLAVE_CLOCK_SOURCE (kCLOCK_IpSrcFircAsync)
#define EXAMPLE_LPSPI_SLAVE_PCS_FOR_INIT (kLPSPI_Pcs1)
#define EXAMPLE_LPSPI_SLAVE_PCS_FOR_TRANSFER (kLPSPI_SlavePcs1)
#define TRANSFER_SIZE (512U)        /*! Transfer dataSize.*/
#define TRANSFER_BAUDRATE (500000U) /*! Transfer baudrate - 500k */

#define PIN_DATA_OR_CMD    2u   /*!< Pin number for pin 3 in a port */

#define ILI9341_SLPOUT     0x11     ///< Sleep Out
#define ILI9341_MADCTL     0x36     ///< Memory Access Control
#define ILI9341_VSCRSADD   0x37     ///< Vertical Scrolling Start Address
#define ILI9341_PIXFMT     0x3A     ///< COLMOD: Pixel Format Set

#define ILI9341_FRMCTR1    0xB1     ///< Frame Rate Control (In Normal Mode/Full Colors)
#define ILI9341_FRMCTR2    0xB2     ///< Frame Rate Control (In Idle Mode/8 colors)
#define ILI9341_FRMCTR3    0xB3     ///< Frame Rate control (In Partial Mode/Full Colors)
#define ILI9341_INVCTR     0xB4     ///< Display Inversion Control
#define ILI9341_DFUNCTR    0xB6     ///< Display Function Control

#define ILI9341_PWCTR1     0xC0     ///< Power Control 1
#define ILI9341_PWCTR2     0xC1     ///< Power Control 2
#define ILI9341_PWCTR3     0xC2     ///< Power Control 3
#define ILI9341_PWCTR4     0xC3     ///< Power Control 4
#define ILI9341_PWCTR5     0xC4     ///< Power Control 5
#define ILI9341_VMCTR1     0xC5     ///< VCOM Control 1
#define ILI9341_VMCTR2     0xC7     ///< VCOM Control 2

#define ILI9341_GMCTRP1    0xE0     ///< Positive Gamma Correction
#define ILI9341_GMCTRN1    0xE1     ///< Negative Gamma Correction
#define ILI9341_GAMMASET   0x26     ///< Gamma Set
#define ILI9341_DISPOFF    0x28     ///< Display OFF
#define ILI9341_DISPON     0x29     ///< Display ON

/**Write to RAM*/
#define CMD_CASET      0x2A
#define CMD_PASET      0x2B
#define CMD_RAMWR      0x2C

/**Fill screen*/
#define CA_LIMIT 0x000000EF
#define PA_LIMIT 0x0000013F

/**Screen size*/
#define ILI_LCD_Y 320U
#define ILI_LCD_X 240U
#define SCREEN_SIZE 76800
#define X_CHAR_LIMIT 15
#define Y_CHAR_LIMIT 15
#define BLOCK_SIZE 242

/**Data for graphics*/
#define COLOR_SHIFT 8
#define COLOR_MASK 0xFF
#define GOTO_XY_SHIFT16 16
#define GOTO_XY_SHIFT24 24
#define XDIFF 120
/*******************************************************************************
* Private type definitions
******************************************************************************/
typedef struct
{
	uint8_t * buffer;
	uint8_t size;
	uint8_t init;
}spi_msg_t;
/*******************************************************************************
* Variables
******************************************************************************/
lpspi_slave_handle_t g_s_handle;

uint8_t masterReceiveBuffer[TRANSFER_SIZE] = {0};
uint8_t masterSendBuffer[TRANSFER_SIZE] = {0};
uint8_t slaveReceiveBuffer[TRANSFER_SIZE] = {0};
uint8_t slaveSendBuffer[TRANSFER_SIZE] = {0};

SemaphoreHandle_t lpspi_sem;

static QueueHandle_t spi_queue = NULL;
static SemaphoreHandle_t spi_sem;

static const uint8_t initLCD[] = {
	3, 0xEF, 0x03, 0x80, 0x02,
	3, 0xCF, 0x00, 0xC1, 0x30,
	4, 0xED, 0x64, 0x03, 0x12, 0x81,
	3, 0xE8, 0x85, 0x00, 0x78,
	5, 0xCB, 0x39, 0x2C, 0x00, 0x34, 0x02,
	1, 0xF7, 0x20,
	2, 0xEA, 0x00, 0x00,
	1, ILI9341_PWCTR1, 0x23,             // Power control VRH[5:0]
	1, ILI9341_PWCTR2, 0x10,             // Power control SAP[2:0];BT[3:0]
	2, ILI9341_VMCTR1, 0x3e, 0x28,       // VCM control
	1, ILI9341_VMCTR2, 0x86,             // VCM control2
	1, ILI9341_MADCTL, 0x48,             // Memory Access Control
	1, ILI9341_VSCRSADD, 0x00,             // Vertical scroll zero
	1, ILI9341_PIXFMT, 0x55,
	2, ILI9341_FRMCTR1, 0x00, 0x18,
	3, ILI9341_DFUNCTR, 0x08, 0x82, 0x27, // Display Function Control
	1, 0xF2, 0x00,                         // 3Gamma Function Disable
	1, ILI9341_GAMMASET, 0x01,             // Gamma curve selected
	15, ILI9341_GMCTRP1, 0x0F, 0x31, 0x2B, 0x0C, 0x0E, 0x08, // Set Gamma
	0x4E, 0xF1, 0x37, 0x07, 0x10, 0x03, 0x0E, 0x09, 0x00,
	15, ILI9341_GMCTRN1, 0x00, 0x0E, 0x14, 0x03, 0x11, 0x07, // Set Gamma
	0x31, 0xC1, 0x48, 0x08, 0x0F, 0x0C, 0x31, 0x36, 0x0F,
	0xAA, ILI9341_SLPOUT, 0x80 ,               // Exit Sleep
	0xAA, ILI9341_DISPON, 0x80                // Display on
};

//this array stores the values of all characters of 6x8
static const int16_t ASCII[][15] =
{		{0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000}, // 20
		{0xfffe, 0xfffe, 0xfffe, 0xfffe, 0xfffe, 0xfffe, 0xfffe, 0xfffe, 0xfffe, 0xfffe, 0xfffe, 0xfffe, 0xfffe, 0xfffe, 0xfffe}, // 21 Blank
		{0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000}, // 22 "
		{0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000}, // 23 #
		{0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000}, // 24 $
		{0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000}, // 25 %
		{0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000}, // 26 &
		{0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000}, // 27 '
		{0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000}, // 28 (
		{0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000}, // 29 )
		{0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000}, // 2a *
		{0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000}, // 2b +
		{0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000}, // 2c ,
		{0x0000, 0x0000, 0x03c0, 0x03c0, 0x03c0, 0x03c0, 0x03c0, 0x03c0, 0x03c0, 0x03c0, 0x03c0, 0x03c0, 0x03c0, 0x0000, 0x0000}, // 2d -
		{0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000}, // 2e .
		{0x0000, 0x0001, 0x000c, 0x003c, 0x00f0, 0x03c0, 0x0f01, 0x3c00, 0xf000, 0xc000, 0x0000, 0x0000, 0x0000, 0x0001, 0x0000}, // 2f /

		{0x0000, 0x0000, 0x0000, 0x3ff0, 0x3ff0, 0xc00c, 0xc00c, 0xc00c, 0xc00c, 0xc00c, 0x3ff0, 0x3ff0, 0x0000, 0x0000, 0x0000}, //0 //30
		{0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x600c, 0x600c, 0xfffc, 0xfffc, 0x000c, 0x000c, 0x0000, 0x0000, 0x0000, 0x0000},//1 //31
		{0x0000, 0x0000, 0x300c, 0x300c, 0xc03c, 0xc03c, 0xc0cc, 0xc0cc, 0xc30c, 0xc30c, 0x3c0c, 0x3c0c, 0x000c, 0x0000, 0x0000},//2 	0x32
		{0x0000, 0x0000, 0x0000, 0x3030, 0x3030, 0xc00c, 0xc00c, 0xc30c, 0xc30c, 0xc30c, 0xc30c, 0x3cf0, 0x3cf0, 0x0000, 0x0000}, //3	0x33
		{0x0000, 0x0000, 0xff00, 0xff00, 0x0300, 0x0300, 0x0300, 0x0300, 0x0300, 0x0300, 0xfffc, 0xfffc, 0x0000, 0x0000, 0x0000},//4	0x34
		{0x0000, 0x0000, 0xff0c, 0xff0c, 0xc30c, 0xc30c, 0xc30c, 0xc30c, 0xc30c, 0xc30c, 0xc30c, 0xc3fc, 0xc3fc, 0x0000, 0x0000},//5	0x35
		{0x0000, 0x0000, 0xfffc, 0xfffc, 0xc30c, 0xc30c, 0xc30c, 0xc30c, 0xc30c, 0xc30c, 0xc30c, 0xc3fc, 0xc3fc, 0x0000, 0x0000},//6 	0x36
		{0x0000, 0x0000, 0xc000, 0xc000, 0xc000, 0xc000, 0xc000, 0xc000, 0xc000, 0xc000, 0xfffc, 0xfffc, 0x0000, 0x0000, 0x0000},//7	0x37
		{0x0000, 0x0000, 0xfffc, 0xfffc, 0xc30c, 0xc30c, 0xc30c, 0xc30c, 0xc30c, 0xc30c, 0xc30c, 0xfffc, 0xfffc, 0x0000, 0x0000},//8	0x38
		{0x0000, 0x0000, 0xff00, 0xff00, 0xc300, 0xc300, 0xc300, 0xc300, 0xc300, 0xc300, 0xc300, 0xfffc, 0xfffc, 0x0000, 0x0000},//9	0x39


		{0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x1c1c, 0x1c1c, 0x1c1c, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000}, // 3a :
		{0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000}, // 3b ;
		{0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000}, // 3c <
		{0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000}, // 3d =
		{0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000}, // 3e >
		{0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000}, // 3f ?
		{0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000}, // 40 @

		{0x0000, 0x3ffc, 0x3ffc, 0xc180, 0xc180, 0xc180, 0xc180, 0xc180, 0xc180, 0xc180, 0xc180, 0xc180, 0x3ffc, 0x3ffc, 0x0000}, //A
		{0x0000, 0xfffc, 0xfffc, 0xc30c, 0xc30c, 0xc30c, 0xc30c, 0xc30c, 0xc30c, 0xc30c, 0xc30c, 0xc30c, 0x3cf0, 0x3cf0, 0x0000}, //B
		{0x0000, 0x3ff0, 0x3ff0, 0xc00c, 0xc00c, 0xc00c, 0xc00c, 0xc00c, 0xc00c, 0xc00c, 0xc00c, 0xc00c, 0x3870, 0x3870, 0x0000}, //C
		{0x0000, 0x0000, 0xfffc, 0xfffc, 0xc00c, 0xc00c, 0xc00c, 0xc00c, 0x3030, 0x3030, 0x3030, 0x0fc0, 0x0fc0, 0x0000, 0x0000}, //D
		{0x0000, 0xfffc, 0xfffc, 0xc30c, 0xc30c, 0xc30c, 0xc30c, 0xc30c, 0xc30c, 0xc00c, 0xc00c, 0xc00c, 0xc00c, 0x0000, 0x0000}, //E
		{0x0000, 0xfffc, 0xfffc, 0xc300, 0xc300, 0xc300, 0xc300, 0xc300, 0xc300, 0xc000, 0xc000, 0xc000, 0xc000, 0x0000, 0x0000}, //F
		{0x0000, 0x3ff0, 0x3ff0, 0xc00c, 0xc00c, 0xc00c, 0xc18c, 0xc18c, 0xc18c, 0xc18c, 0xc18c, 0xc18c, 0x39f0, 0x39f0, 0x0000}, //G
		{0x0000, 0xfffc, 0xfffc, 0x0300, 0x0300, 0x0300, 0x0300, 0x0300, 0x0300, 0x0300, 0x0300, 0x0300, 0xfffc, 0xfffc, 0x0000}, //H
		{0x0000, 0x0000, 0xc00c, 0xc00c, 0xc00c, 0xc00c, 0xc00c, 0xfffc, 0xfffc, 0xc00c, 0xc00c, 0xc00c, 0xc00c, 0xc00c, 0x0000}, //I
		{0x0000, 0x0000, 0x0060, 0x0060, 0x0018, 0x0018, 0x0018, 0x0018, 0x0018, 0x0018, 0x0018, 0x0018, 0xfff8, 0xfff8, 0x0000}, //J
		{0x0000, 0x0000, 0x0000, 0x0000, 0x7ffc, 0x7ffc, 0x0300, 0x0300, 0x0cc0, 0x0cc0, 0x703c, 0x703c, 0x0000, 0x0000, 0x0000},//K
		{0x0000, 0x0000, 0xfffc, 0xfffc, 0x000c, 0x000c, 0x000c, 0x000c, 0x000c, 0x000c, 0x000c, 0x000c, 0x000c, 0x000c, 0x0000}, //L
		{0xfffc, 0xfffc, 0x6000, 0x6000, 0x1800, 0x1800, 0x0600, 0x0600, 0x1800, 0x1800, 0x6000, 0x6000, 0xfffc, 0xfffc, 0x0000}, //M
		{0x0000, 0x0000, 0x0000, 0xfffc, 0xfffc, 0xf000, 0xf000, 0x0f80, 0x0f80, 0x007c, 0x007c, 0xfffc, 0xfffc, 0x0000, 0x0000}, //N
		{0x0000, 0x3ff0, 0x3ff0, 0xc00c, 0xc00c, 0xc00c, 0xc00c, 0xc00c, 0xc00c, 0xc00c, 0xc00c, 0xc00c, 0x3ff0, 0x3ff0, 0x0000}, //O
		{0x0000, 0xfffc, 0xfffc, 0xc300, 0xc300, 0xc300, 0xc300, 0xc300, 0xc300, 0xc300, 0xc300, 0x3c00, 0x3c00, 0x0000, 0x0000}, //P
		{0x0000, 0x3ff0, 0x3ff0, 0xc00c, 0xc00c, 0xc00c, 0xc00c, 0xc18c, 0xc18c, 0xc06c, 0xc06c, 0xc00c, 0x3ffc, 0x3ffe, 0x0006}, //Q
		{0x0000, 0x0000, 0x3ffc, 0x3ffc, 0xc380, 0xc3c0, 0xc3c0, 0xc360, 0xc370, 0xc338, 0xc31c, 0x3c0c, 0x3c0c, 0x0000, 0x0000},//R
		{0x0000, 0x0000, 0x3e0c, 0x3e0c, 0xc30c, 0xc30c, 0xc30c, 0xc30c, 0xc30c, 0xc30c, 0xc30c, 0xc0f0, 0xc0f0, 0x0000, 0x0000},//S
		{0x0000, 0x0000, 0xc000, 0xc000, 0xc000, 0xc000, 0xc000, 0xfffc, 0xfffc, 0xc000, 0xc000, 0xc000, 0xc000, 0xc000, 0x0000},//T
		{0x0000, 0xfff0, 0xfff0, 0x000c, 0x000c, 0x000c, 0x000c, 0x000c, 0x000c, 0x000c, 0x000c, 0xfff0, 0xfff0, 0x0000, 0x0000},//U
		{0x0000, 0xff00, 0xff00, 0x00c0, 0x00c0, 0x0030, 0x0030, 0x000c, 0x000c, 0x0030, 0x0030, 0x00c0, 0x00c0, 0xff00, 0xff00},//V
		{0x0000, 0x0000, 0xfff8, 0xfff8, 0x0018, 0x0078, 0x0060, 0x0180, 0x0180, 0x0060, 0x0078, 0x0018, 0xfff8, 0xfff8, 0x0000}, //W
		{0x0000, 0xc00c, 0xc00c, 0x3030, 0x3030, 0x0cc0, 0x0cc0, 0x0300, 0x0cc0, 0x0cc0, 0x3030, 0x3030, 0xc00c, 0xc00c, 0x0000}, //X
		{0x0000, 0xfc00, 0xfc00, 0x0300, 0x0300, 0x0300, 0x03fc, 0x03fc, 0x0300, 0x0300, 0x0300, 0xfc00, 0xfc00, 0x0000, 0x0000}, //Y
		{0x0000, 0x0000, 0xc03c, 0xc03c, 0xc0cc, 0xc0cc, 0xc30c, 0xc30c, 0xcc0c, 0xcc0c, 0xf00c, 0xf00c, 0x0000, 0x0000, 0x0000}, //Z


		{0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000}, // 5b [
		{0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000}, // 5c ï¿½
		{0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000}, // 5d ]
		{0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000}, // 5e ^
		{0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000}, // 5f _
		{0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000}, // 60

		{0x0000, 0x0000, 0x0000, 0x03f0, 0x03f0, 0x0c0c, 0x0c0c, 0x0c0c, 0x0c0c, 0x0c30, 0x0c30, 0x03fc, 0x03fc, 0x0000, 0x0000},//a //0x61
		{0x0000, 0x0000, 0x7ffc, 0x7ffc, 0x030c, 0x030c, 0x030c, 0x030c, 0x030c, 0x030c, 0x00f0, 0x00f0, 0x0000, 0x0000, 0x0000},//b
		{0x0000, 0x0000, 0x03f0, 0x03f0, 0x0c0c, 0x0c0c, 0x0c0c, 0x0c0c, 0x0c0c, 0x0c0c, 0x0c0c, 0x0c0c, 0x0000, 0x0000, 0x0000},//c
		{0x0000, 0x0000, 0x00f0, 0x00f0, 0x030c, 0x030c, 0x030c, 0x030c, 0x030c, 0x030c, 0x7ff0, 0x7ff0, 0x0000, 0x0000, 0x0000},//d
		{0x0000, 0x03f0, 0x03f0, 0x0ccc, 0x0ccc, 0x0ccc, 0x0ccc, 0x0ccc, 0x0ccc, 0x030c, 0x030c, 0x0000, 0x0000, 0x0000, 0x0000},//e
		{0x0000, 0x0000, 0x0ffc, 0x0ffc, 0x30c0, 0x30c0, 0x30c0, 0x30c0, 0x3000, 0x0c00, 0x0c00, 0x0000, 0x0000, 0x0000, 0x0000},//f
		{0x0000, 0x0000, 0x0f18, 0x0f18, 0x30c6, 0x30c6, 0x30c6, 0x30c6, 0x30c6, 0x30c6, 0x0ffc, 0x0ffc, 0x0000, 0x0000, 0x0000},//g
		{0x0000, 0x0000, 0x3ffc, 0x3ffc, 0x0180, 0x0180, 0x0180, 0x0180, 0x0180, 0x0180, 0x007c, 0x007c, 0x0000, 0x0000, 0x0000},//h
		{0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x33fc, 0x33fc, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000},//i
		{0x0000, 0x0000, 0x0000, 0x0000, 0x0078, 0x0078, 0x0006, 0x0006, 0x0006, 0x0006, 0x37f8, 0x37f8, 0x0000, 0x0000, 0x0000},//j
		{0x0000, 0x0000, 0x3ffc, 0x3ffc, 0x03c0, 0x03c0, 0x0c30, 0x0c30, 0x300c, 0x300c, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000},//k
		{0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x3ffc, 0x3ffc, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000},//l
		{0x0000, 0x0000, 0x07fc, 0x07fc, 0x0600, 0x0600, 0x0600, 0x07fc, 0x07fc, 0x0600, 0x0600, 0x0600, 0x01fc, 0x01fc, 0x0000},//m
		{0x0000, 0x0000, 0x0000, 0x07fc, 0x07fc, 0x0180, 0x0180, 0x0600, 0x0600, 0x0600, 0x0600, 0x01fc, 0x01fc, 0x0000, 0x0000},//n
		{0x0000, 0x0000, 0x0000, 0x0000, 0x07f0, 0x07f0, 0x180c, 0x180c, 0x180c, 0x180c, 0x07f0, 0x07f0, 0x0000, 0x0000, 0x0000},//o
		{0x0000, 0x0000, 0x0ffc, 0x0ffc, 0x30c0, 0x30c0, 0x30c0, 0x30c0, 0x30c0, 0x30c0, 0x0f00, 0x0f00, 0x0000, 0x0000, 0x0000},//p
		{0x0000, 0x0000, 0x0f00, 0x0f00, 0x30c0, 0x30c0, 0x30c0, 0x30c0, 0x30c0, 0x30c0, 0x0ffc, 0x0ffc, 0x0000, 0x0000, 0x0000},//q
		{0x0000, 0x0000, 0x3ffc, 0x3ffc, 0x0c00, 0x0c00, 0x3000, 0x3000, 0x3000, 0x3000, 0x0f00, 0x0f00, 0x0000, 0x0000, 0x0000},//r
		{0x0000, 0x0000, 0x0000, 0x0000, 0x0e0c, 0x0e0c, 0x318c, 0x318c, 0x318c, 0x318c, 0x318c, 0x318c, 0x0070, 0x0070, 0x0000},//s
		{0x0000, 0x0000, 0x0000, 0x1800, 0x1800, 0x7ffc, 0x7ffc, 0x1800, 0x1800, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000},//t
		{0x0000, 0x0000, 0x0000, 0x0ff0, 0x0ff0, 0x000c, 0x000c, 0x000c, 0x000c, 0x0ff0, 0x0ff0, 0x0000, 0x0000, 0x0000, 0x0000},//u
		{0x0000, 0x0000, 0x0fc0, 0x0fc0, 0x0030, 0x0030, 0x000c, 0x000c, 0x0030, 0x0030, 0x0fc0, 0x0fc0, 0x0000, 0x0000, 0x0000},//v
		{0x0000, 0x1ff0, 0x1ff0, 0x000c, 0x000c, 0x000c, 0x000c, 0x00f0, 0x00f0, 0x000c, 0x000c, 0x000c, 0x000c, 0x1ff0, 0x1ff0},//w
		{0x0000, 0x0000, 0x0c0c, 0x0c0c, 0x0330, 0x0330, 0x00c0, 0x00c0, 0x0330, 0x0330, 0x0c0c, 0x0c0c, 0x0000, 0x0000, 0x0000},//x
		{0x0000, 0x0000, 0x0000, 0x0718, 0x0718, 0x00c6, 0x00c6, 0x00c6, 0x00c6, 0x07f8, 0x07f8, 0x0000, 0x0000, 0x0000, 0x0000},//y
		{0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0c1c, 0x0c1c, 0x0c6c, 0x0c6c, 0x0d8c, 0x0d8c, 0x0f0c, 0x0f0c, 0x0000, 0x0000},//z 0x7A
};

static const uint8_t* s0 = {"VEGA BOARD DEMO", NULL};
static const uint8_t* s1 = {"Corriente Medida", NULL};
static const uint8_t* s2 = {"Calculo potencia", NULL};
/*******************************************************************************
 * Definitions
 ******************************************************************************/
/* Task priorities. */
#define slave_task_PRIORITY (configMAX_PRIORITIES - 2)
#define master_task_PRIORITY (configMAX_PRIORITIES - 1)
#define screen_task_PRIORITY (configMAX_PRIORITIES - 3)

/*******************************************************************************
 * Prototypes
 ******************************************************************************/
/* LPSPI user callback */
void LPSPI_SlaveUserCallback(LPSPI_Type *base, lpspi_slave_handle_t *handle, status_t status, void *userData);
void LCD_ILI9341_writeColor(uint16_t x, uint16_t y, uint16_t color);

static void master_task(void *pvParameters);
static void screen_task(void *pvParameters);
/*******************************************************************************
 * Code
 ******************************************************************************/
/*!
 * @brief Application entry point.
 */
void LCD_ILI9341_init(void)
{
    /* Define the init structure for the output LED pin*/
	gpio_pin_config_t out_config = {
		kGPIO_DigitalOutput, 0,
	};

	/* Init output pins */
	GPIO_PinInit(GPIOB, PIN_DATA_OR_CMD, &out_config);

    /* Set clock source for LPSPI and get master clock source */
    CLOCK_SetIpSrc(EXAMPLE_LPSPI_MASTER_CLOCK_NAME, EXAMPLE_LPSPI_MASTER_CLOCK_SOURCE);
    CLOCK_SetIpSrc(EXAMPLE_LPSPI_SLAVE_CLOCK_NAME, EXAMPLE_LPSPI_SLAVE_CLOCK_SOURCE);

    /* Enable LPI2C0 intmux source on INTMUX channel 0 */
    INTMUX_Init(INTMUX0);
    INTMUX_EnableInterrupt(INTMUX0, 0, EXAMPLE_LPSPI_SLAVE_IRQN);

    /* Set IRQ priority */
    NVIC_SetPriority(INTMUX0_0_IRQn, 1);
    NVIC_SetPriority(EXAMPLE_LPSPI_MASTER_IRQN, 2);

    PRINTF("FreeRTOS LPSPI example start.\r\n");

    spi_queue = xQueueCreate(10, sizeof(spi_msg_t));
    spi_sem = xSemaphoreCreateBinary();

    if (xTaskCreate(master_task, "Master_task", configMINIMAL_STACK_SIZE + 64, NULL, master_task_PRIORITY, NULL) != pdPASS)
    {
        PRINTF("Task creation failed!.\r\n");
        while (1)
            ;
    }

    if (xTaskCreate(screen_task, "Screen_task", configMINIMAL_STACK_SIZE + 64, NULL, screen_task_PRIORITY, NULL) != pdPASS)
	{
		PRINTF("Task creation failed!.\r\n");
		while (1)
			;
	}
}

/*!
 * @brief Data structure and callback function for slave SPI communication.
 */

typedef struct _callback_message_t
{
    status_t async_status;
    SemaphoreHandle_t sem;
} callback_message_t;

void LPSPI_SlaveUserCallback(LPSPI_Type *base, lpspi_slave_handle_t *handle, status_t status, void *userData)
{
    callback_message_t *cb_msg = (callback_message_t *)userData;
    BaseType_t reschedule;

    cb_msg->async_status = status;
    xSemaphoreGiveFromISR(cb_msg->sem, &reschedule);
    portYIELD_FROM_ISR(reschedule);
}

/*!
 * @brief Task responsible for master SPI communication.
 */
static void master_task(void *pvParameters)
{
    lpspi_transfer_t masterXfer;
    lpspi_rtos_handle_t master_rtos_handle;
    lpspi_master_config_t masterConfig;
    uint32_t sourceClock;
    status_t status;

    /*
     * masterConfig.bitsPerFrame = 8;
     * masterConfig.cpol = kLPSPI_ClockPolarityActiveHigh;
     * masterConfig.cpha = kLPSPI_ClockPhaseFirstEdge;
     * masterConfig.direction = kLPSPI_MsbFirst;
     * masterConfig.whichPcs = kLPSPI_Pcs0;
     * masterConfig.pcsActiveHighOrLow = kLPSPI_PcsActiveLow;
     * masterConfig.pinCfg = kLPSPI_SdiInSdoOut;
     * masterConfig.dataOutConfig = kLpspiDataOutRetained;
     */
    LPSPI_MasterGetDefaultConfig(&masterConfig);

    masterConfig.baudRate = TRANSFER_BAUDRATE;
    masterConfig.bitsPerFrame = 8;
    masterConfig.cpol = kLPSPI_ClockPolarityActiveHigh;
    masterConfig.cpha = kLPSPI_ClockPhaseFirstEdge;
    masterConfig.direction = kLPSPI_MsbFirst;
    masterConfig.pcsToSckDelayInNanoSec = 1000000000 / masterConfig.baudRate;
    masterConfig.lastSckToPcsDelayInNanoSec = 1000000000 / masterConfig.baudRate;
    masterConfig.betweenTransferDelayInNanoSec = 1000000000 / masterConfig.baudRate;
    masterConfig.whichPcs = EXAMPLE_LPSPI_MASTER_PCS_FOR_INIT;
    masterConfig.pcsActiveHighOrLow = kLPSPI_PcsActiveLow;
    masterConfig.pinCfg = kLPSPI_SdiInSdoOut;
    masterConfig.dataOutConfig = kLpspiDataOutRetained;

    sourceClock = EXAMPLE_LPSPI_MASTER_CLOCK_FREQ;

    status = LPSPI_RTOS_Init(&master_rtos_handle, EXAMPLE_LPSPI_MASTER_BASEADDR, &masterConfig, sourceClock);

    if (status != kStatus_Success)
    {
        PRINTF("LPSPI master: error during initialization. \r\n");
        vTaskSuspend(NULL);
    }

    /*Start master transfer*/
	masterXfer.rxData = masterReceiveBuffer;

	masterXfer.configFlags = EXAMPLE_LPSPI_MASTER_PCS_FOR_TRANSFER | kLPSPI_MasterPcsContinuous | kLPSPI_SlaveByteSwap;

	spi_msg_t msg;

	while(true)
	{
		xQueueReceive(spi_queue, &msg, portMAX_DELAY);

		uint8_t delayFlag = false;
		while(msg.size > 0)
		{
			/*Determine msg size*/
			if(*msg.buffer == 0xAA && msg.init)
			{
				masterXfer.dataSize = 2;
				delayFlag = true;
			}

			else
			{
				masterXfer.dataSize = *msg.buffer + 1;
			}

			msg.size -= (masterXfer.dataSize + 1);
			msg.buffer++;
			masterXfer.txData = msg.buffer;
			LPSPI_RTOS_Transfer(&master_rtos_handle, &masterXfer);
			msg.buffer += masterXfer.dataSize;

			if(delayFlag)
			{
				/*Waits for screen to turn on*/
				vTaskDelay(1000);
				delayFlag = false;
			}

		}

		GPIO_ClearPinsOutput(GPIOB, 1 << PIN_DATA_OR_CMD);
		xSemaphoreGive(spi_sem);
	}

    vTaskSuspend(NULL);
}

static void screen_task(void *pvParameters)
{
	spi_msg_t msg;

	msg.buffer = &initLCD;
	msg.init = true;
	msg.size = sizeof(initLCD);

	//Reset LCD
	GPIO_SetPinsOutput(GPIOB, 1 << PIN_DATA_OR_CMD);
	vTaskDelay(10);
	GPIO_ClearPinsOutput(GPIOB, 1 << PIN_DATA_OR_CMD);

	//Write configuration
	xQueueSend(spi_queue,&msg,portMAX_DELAY);
	xSemaphoreTake(spi_sem, portMAX_DELAY);
	msg.init = false;

	LCD_ILI9341_fillScreen(ILI9341_CYAN);

	LCD_ILI9341_sendString(8, 1, ILI9341_BLACK, s0);
	LCD_ILI9341_sendString(0, 48, ILI9341_BLACK, s1);
	LCD_ILI9341_sendString(0, 128, ILI9341_BLACK, s2);
	xSemaphoreTake(spi_sem, portMAX_DELAY);
	vTaskSuspend(NULL);
}

void LCD_ILI9341_gotoXY(uint32_t x, uint32_t y)
{
	spi_msg_t msg;

	uint8_t gotoXY[12] = {
			4, CMD_CASET, (x >> GOTO_XY_SHIFT24), (x >> GOTO_XY_SHIFT16) & COLOR_MASK,
			(x >> COLOR_SHIFT) & COLOR_MASK, x & COLOR_MASK,
			4, CMD_PASET, (y >> GOTO_XY_SHIFT24), (y >> GOTO_XY_SHIFT16) & COLOR_MASK,
			(y >> COLOR_SHIFT) & COLOR_MASK, y & COLOR_MASK
	};

	msg.buffer = &gotoXY;
	msg.size = sizeof(gotoXY);

	//Write commands
	xQueueSend(spi_queue,&msg,portMAX_DELAY);
}

void LCD_ILI9341_fillScreen(uint16_t color)
{
	LCD_ILI9341_drawLines(0, ILI_LCD_Y, color);
}

void LCD_ILI9341_writeColor(uint16_t x, uint16_t y, uint16_t color)
{
	spi_msg_t msg;

	/**Indicate position and margin*/
	uint32_t newX = (x << GOTO_XY_SHIFT16) | x;
	uint32_t newY = (y << GOTO_XY_SHIFT16) | y;

	/**Go to intoduced coordinates*/
	LCD_ILI9341_gotoXY(newX, newY);

	uint8_t data[4] = {2, CMD_RAMWR, (color >> COLOR_SHIFT), (color & COLOR_MASK)};
	msg.buffer = &data;
	msg.size = sizeof(data);

	xQueueSend(spi_queue,&msg,portMAX_DELAY);
	xSemaphoreTake(spi_sem, portMAX_DELAY);
	vTaskDelay(2);
}

void LCD_ILI9341_writeCharacter(uint16_t x, uint16_t y, uint16_t color, uint8_t character)
{
	uint16_t x_index= false;
	uint16_t x_index2= false;
	uint16_t y_index= false;
	uint32_t temporalValue = false;
	uint32_t temporalASCII = false;
	uint8_t shift_helper;

	/**Loop for x axis*/
	for(x_index = x; x_index < x + X_CHAR_LIMIT; x_index++)
	{
		shift_helper = Y_CHAR_LIMIT;
		/**Gets ASCII bitmap value to write*/
		temporalASCII = (ASCII[character-0x20][x_index2]);
		/**Loop for y axis*/
		for(y_index = y; y_index < y + Y_CHAR_LIMIT; y_index++)
		{
			/**If the given position contains a pixel, write it*/
			temporalValue = (temporalASCII >> shift_helper);
			temporalValue =  temporalValue & true;
			if(temporalValue)
				LCD_ILI9341_writeColor(x_index, y_index , color);
			shift_helper--;
		}

		x_index2++;
	}
}

void LCD_ILI9341_sendString(uint16_t x, uint16_t y, uint16_t color,const uint8_t *characters)
{
	/**While string has some data to print*/
	while (*characters)
	{
	  /**Write a character*/
	  LCD_ILI9341_writeCharacter(x, y, color,*characters++);
	  /**Increment x position*/
	  x += X_CHAR_LIMIT;
	}
}

void LCD_ILI9341_drawLines(uint16_t y, uint16_t nLines, uint16_t color)
{
	uint16_t index;
	spi_msg_t msg;

	uint8_t data[BLOCK_SIZE];

	data[0] = 240;
	data[1] = CMD_RAMWR;

	msg.buffer = &data;
	msg.size = sizeof(data);

	for(index = 2; index < BLOCK_SIZE; index++)
	{
		data[index++] = color >> COLOR_SHIFT;
		data[index] = color & COLOR_MASK;
	}

	for(index = y; index < (nLines + y); index++)
	{
		uint32_t newY;
		uint32_t newX;

		/*Calculate new pages to write*/
		newY = (index << GOTO_XY_SHIFT16) | (index);
		newX = XDIFF - 1;

		/*Go to indicated position*/
		LCD_ILI9341_gotoXY(newX, newY);

		/*Send data*/
		xQueueSend(spi_queue,&msg,portMAX_DELAY);
		xSemaphoreTake(spi_sem, portMAX_DELAY);

		/*Wait for data to be displayed in screen*/
		vTaskDelay(20);

		/*Repeat for second row*/
		newX = ((XDIFF << GOTO_XY_SHIFT16) | (2*XDIFF - 1));
		LCD_ILI9341_gotoXY(newX, newY);

		xQueueSend(spi_queue,&msg,portMAX_DELAY);
		xSemaphoreTake(spi_sem, portMAX_DELAY);
		vTaskDelay(20);
	}
}
